package org.scictrl.mp.orbitcorrect;

/**
 * This class was generated by a SmartGuide.
 *
 * @author igor@scictrl.com
 */
public final class DBMath {
/**
 * Tells to assamble matrix only elements concerning X axis.
 */
	public static final int X_PART=1;
/**
 * Tells to assamble matrix only elements concerning Z axis.
 */
	public static final int Z_PART=2;
/**
 * Tells to assamble whole matrix.
 */
	public static final int BOTH=3;
/**
 * Charge of electron in As.
 */
	public static final double CHARGE= 1.60217733E-19;
/**
 * m*DBMath.C^2 where m is mass of electron.
 */
	public static final double MC2= 0.51099906e-3;
/**
 * Speed of light in vacum.
 */
	public static final double C= 299792458;
	/** Constant <code>K_MAD=-1</code> */
	public static final int K_MAD=-1;
	/** Constant <code>K_WILLE=1</code> */
	public static final int K_WILLE=1;
	/** Constant <code>K_CONVENTION=K_MAD</code> */
	public static byte K_CONVENTION=K_MAD;
/**
 * Don't let anyone instantiate this class.
 */
private DBMath() {}
/**
 * <p>checkDimension.</p>
 *
 * @param matrix an array of {@link double} objects
 * @throws java.lang.ArrayIndexOutOfBoundsException if any.
 */
public final static void checkDimension(double[][] matrix) throws java.lang.ArrayIndexOutOfBoundsException {
	if (matrix.length!=5 && matrix[0].length!=5) throw new ArrayIndexOutOfBoundsException("Not 5x5 matrix!");
}
/**
 * Returns copy of <code>double[][]</code> matrix.
 * All sub-arrays must be the same length.
 *
 * @param m a <code>double[][]</code> matrix
 * @return the copy of argument
 */
public static double[][] clone(double[][] m) {
	if (m==null) return null;
	int a= m.length;
	int b= m[0].length;
	double[][] c= new double[a][b];
	for (int i=0; i<a; i++)
		for (int j=0; j<b; j++)
			c[i][j]= m[i][j];
	return c;
}
/**
 * Returns the hyperbolic cosine of <code>double</code> value.
 *
 * @param a <code>double</code> value
 * @return the hyperbolic cosine of argument
 */
public static double cosh (double a) {
	return (Math.exp(a)+ Math.exp(-a))/2.0;
}
/**
 * Assembles defocusing transfere matrix for magnet with quadrupole field.
 * Defocussing part is in upper left corner and focussing in bottom right.
 *
 * @param k the <code>double</code> quadrupole stength of magnet
 * @param length the <code>double</code> length of magnet
 * @param m the <code>double[][]</code> matrix to be edited
 * @param how it specifies which part of quadrupole matrix is to be assembeled: RingMath.X_PART, RingMath.Z_PART, RingMath.BOTH
 */
public static void defocussing(double k, double length, double[][] m,int how ) {
	if (how!=2){
		m[0][0]= cosh(k*length);
		m[1][1]= m[0][0];
		m[0][1]= sinh(k*length)/k;
		m[1][0]= sinh(k*length)*k;
	}
	if (how>1){
	 	m[2][2]= Math.cos(k*length);
	 	m[3][3]= m[2][2];
	 	m[2][3]= Math.sin(k*length)/k;
	 	m[3][2]= -Math.sin(k*length)*k;
	}
}
/**
 * Assambles focusing matrix for magnet with quadrupole momentum.
 * Docussing part is in upper left corner and defocussing in bottom right.
 *
 * @param k the <code>double</code> quadrupole stength of magnet
 * @param length the <code>double</code> length of magnet
 * @param m the <code>double[5][5]</code> matrix to be edited
 * @param how it specifies which part of quadrupole matrix is to be assambeled: RingMath.X_PART, RingMath.Z_PART, RingMath.BOTH.
 */
public static void focussing (double k, double length, double[][] m, int how) {
	if (how!=2){
		m[0][0]= Math.cos(k*length);
		m[1][1]= m[0][0];
		m[0][1]= Math.sin(k*length)/k;
		m[1][0]= -Math.sin(k*length)*k;
	}
	if (how>1){
		m[2][2]= cosh(k*length);
		m[3][3]= m[2][2];
		m[2][3]= sinh(k*length)/k;
		m[3][2]= sinh(k*length)*k;
	}
}
	/**
	 * Returns 5x5 dimensional identity matrix.
	 *
	 * @return the <code>double[5][5]</code> identity matrix
	 */
	public static double[][] identity(){
		double[][] c= new double[5][5];
		for (int i=0; i<5; i++)
			c[i][i]= 1.0;
		return c;
	}
	/**
	 * Returns identity matrix.
	 *
	 * @return the identity matrix
	 * @param m an array of {@link double} objects
	 */
	public static double[][] identity(double[][] m ){
		for (int i = 0; i < m.length; i++) {
			for (int j = 0; j < m[0].length; j++) {
				if (i==j) {
					m[i][j]=1.0;
				} else {
					m[i][j]=0.0;
				}
			}
		}
		return m;
	}
/**
 * Creates 5x5 matrix with beta function. Its used to transfer beta values throu system.
 *
 * @return the <code>double[5][5]</code> beta matrix
 * @param betaX a double
 * @param betaZ a double
 * @param alphaX a double
 * @param alphaZ a double
 */
public static double[][] makeBetaMatrix(double betaX, double betaZ, double alphaX, double alphaZ) {
	return makeBetaMatrix(betaX,betaZ,alphaX,alphaZ,new double[5][5]);
}
/**
 * Creates 5x5 matrix with beta function. Its used to transfer beta values throu system.
 *
 * @return the <code>double[5][5]</code> beta matrix
 * @param betaX a double
 * @param betaZ a double
 * @param alphaX a double
 * @param alphaZ a double
 * @param m an array of {@link double} objects
 */
public static double[][] makeBetaMatrix(double betaX, double betaZ, double alphaX, double alphaZ, double[][] m) {
	checkDimension(m);
	m[0][0]= betaX;
	m[0][1]= -alphaX;
	m[1][0]= -alphaX;
	m[1][1]= (1 + sqr(alphaX))/betaX;

	m[2][2]= betaZ;
	m[2][3]= -alphaZ;
	m[3][2]= -alphaZ;
	m[3][3]= (1 + sqr(alphaZ))/betaZ;

	return m;
}
/**
 * Creates 5x5 matrix with beta function. Its used to transfer beta values throu system.
 *
 * @return the <code>double[5][5]</code> beta matrix
 * @param beta a {@link org.scictrl.mp.orbitcorrect.model.optics.PositionedData} object
 * @param alpha a {@link org.scictrl.mp.orbitcorrect.model.optics.PositionedData} object
 */
public static double[][] makeBetaMatrix(org.scictrl.mp.orbitcorrect.model.optics.PositionedData beta, org.scictrl.mp.orbitcorrect.model.optics.PositionedData alpha) {
	double[][] m= new double[5][5];
	m[0][0]= beta.x();
	m[0][1]= -alpha.x();
	m[1][0]= -alpha.x();
	m[1][1]= (1 + sqr(alpha.x()))/beta.x();

	m[2][2]= beta.z();
	m[2][3]= -alpha.z();
	m[3][2]= -alpha.z();
	m[3][3]= (1 + sqr(alpha.z()))/beta.z();

	return m;
}
/**
 * Creates matrix representing bending magnet.
 *
 * @return the <code>double[5][5]</code> bending matrix
 * @param r a double
 * @param length a double
 */
public static double[][] makeDipole(double r, double length) {
	return makeDipole(r,length,new double[5][5]);
}
/**
 * Creates matrix representing bending magnet.
 *
 * @return the <code>double[5][5]</code> bending matrix
 * @param r a double
 * @param length a double
 * @param m an array of {@link double} objects
 */
public static double[][] makeDipole(double r, double length, double[][] m) {
	checkDimension(m);
	m[0][0]= Math.cos(length/r);
	m[1][1]= m[0][0];
	m[0][1]= Math.sin(length/r)*r;
	m[1][0]= -Math.sin(length/r)/r;

	m[2][2]= 1.0;
	m[2][3]= length;
	m[3][2]= 0.0;
	m[3][3]= 1.0;

	m[4][4]= 1.0;

	m[0][4]= (1.0-Math.cos(length/r))*r;
	m[1][4]= Math.sin(length/r);

	return m;
}
/**
 * Creates matrix representing bending magnet.
 *
 * @return the <code>double[5][5]</code> bending matrix
 * @param r a double
 * @param k a double
 * @param length a double
 */
public static double[][] makeDipole(double r, double k, double length) {
	if (k==0.0) return makeDipole(r,length);
	return makeDipole(r,k,length,new double[5][5]);
}
/**
 * Creates matrix representing bending magnet.
 *
 * @return the <code>double[5][5]</code> bending matrix
 * @param r a double
 * @param k a double
 * @param length a double
 * @param matrix an array of {@link double} objects
 */
public static double[][] makeDipole(double r, double k, double length, double[][] matrix) {
	checkDimension(matrix);
	if (k==0.0) return makeDipole(r,length,matrix);
	double f= 1.0/(r*r)-K_CONVENTION*k;
	double kk= Math.sqrt(Math.abs(f));
	if (f>0){
		focussing(kk,length,matrix,BOTH);
		matrix[0][4]= (1.0-Math.cos(kk*length))/kk;
//		matrix[0][4]= (1.0-Math.cos(kk*length))*r;
		matrix[1][4]= Math.sin(kk*length);
	}
	else{
		defocussing(kk,length,matrix,BOTH);
		matrix[0][4]= (1.0-cosh(kk*length))/kk;
		matrix[1][4]= -sinh(kk*length);
	}
	matrix[2][2]= 1.0;
	matrix[2][3]= length;
	matrix[3][2]= 0.0;
	matrix[3][3]= 1.0;
	matrix[4][4]= 1.0;
	return matrix;
}
/**
 * Creates 5x5 matrix with beta function. Its used to transfer beta values throu system.
 *
 * @return the <code>double[5][5]</code> beta matrix
 * @param d a double
 * @param dp a double
 */
public static double[] makeDispersionVector(double d, double dp) {
	double[] dis= new double[5];
	dis[0]= d;
	dis[1]= dp;
	dis[2]=0.0;
	dis[3]=0.0;
	dis[4]=1.0;
	return dis;
}
/**
 * Creates 5x5 matrix with beta function. Its used to transfer beta values throu system.
 *
 * @return the <code>double[5][5]</code> beta matrix
 * @param d a {@link org.scictrl.mp.orbitcorrect.model.optics.DispersionData} object
 */
public static double[] makeDispersionVector(org.scictrl.mp.orbitcorrect.model.optics.DispersionData d) {
	double[] dis= new double[5];
	dis[0]= d.d();
	dis[1]= d.dp();
	dis[2]=0.0;
	dis[3]=0.0;
	dis[4]=1.0;
	return dis;
}
/**
 * Creates matrix representing enpty drift space.
 *
 * @return the <code>double[5][5]</code> drift matrix
 * @param length a double
 */
public static double[][] makeDrift(double length) {
	return makeDrift(length,new double[5][5]);
}
/**
 * Creates matrix representing enpty drift space.
 *
 * @return the <code>double[5][5]</code> drift matrix
 * @param length a double
 * @param matrix an array of {@link double} objects
 */
public static double[][] makeDrift(double length, double[][] matrix) {
	checkDimension(matrix);
	matrix[0][0]= 1.0;
	matrix[0][1]= length;
	matrix[1][0]= 0.0;
	matrix[1][1]= 1.0;

	matrix[2][2]= 1.0;
	matrix[2][3]= length;
	matrix[3][2]= 0.0;
	matrix[3][3]= 1.0;

	matrix[4][4]= 1.0;

	return matrix;
}
/**
 * Creates matrix representing quadrupole magnet.
 *
 * @return the <code>double[5][5]</code> quadrupole matrix
 * @param k a double
 * @param length a double
 */
public static double[][] makeQuadrupole(double k, double length) {
	return makeQuadrupole(k,length,new double[5][5]);
}
/**
 * Creates matrix representing quadrupole magnet.
 *
 * @return the <code>double[5][5]</code> quadrupole matrix
 * @param k a double
 * @param length a double
 * @param matrix an array of {@link double} objects
 */
public static double[][] makeQuadrupole(double k, double length, double[][] matrix) {
	checkDimension(matrix);
	if (K_CONVENTION*k<0) focussing(Math.sqrt(Math.abs(k)),length,matrix,BOTH);
	else defocussing(Math.sqrt(Math.abs(k)),length,matrix,BOTH);
	matrix[4][4]= 1.0;
	return matrix;
}
/**
 * Creates 5x5 matrix representing wedge foccusing correction on rectangular bending magnet.
 * If dipole magnet is rectangular, it's matrix is multiplyed from left and right with this matrix.
 *
 * @return the <code>double[5][5]</code> wedge focussing matrix
 * @param angle a double
 * @param r a double
 */
public static double[][] makeWedge(double angle, double r) {
	double[][] matrix= new double[5][5];
	matrix[0][0]= 1.0;
	matrix[0][1]= 0.0;
	matrix[1][0]= Math.tan(angle)/r;
	matrix[1][1]= 1.0;

	matrix[2][2]= 1.0;
	matrix[2][3]= 0.0;
	matrix[3][2]= -matrix[1][0];
	matrix[3][3]= 1.0;

	matrix[4][4]= 1.0;

	return matrix;
}
/**
 * Return calculated phase shift of transfer matrix.
 *
 * <code>which</code> tells wich space axsis to calculate. Valid values are <code>X_PART</code> and <code>Z_PART</code>.
 *
 * @return <code>double</code> calculated phase shift
 * @param m <code>double[5][5]</code> transfer matrix
 * @param beta <code>double</code> beta function
 * @param alpha <code>double</code> optical function
 * @param which axsis to be calculated
 */
public static double matrixPhase (double[][] m, double beta, double alpha , int which) {
	int a=0;
	switch (which) {
		case X_PART: a=0;
			break;
		case Z_PART: a=2;
			break;
		case BOTH: return 0;
	}
	double c= Math.atan(m[a][a+1]/(m[a][a]*beta-m[a][a+1]*alpha))/2.0/Math.PI;
	if (c<0) c+= 0.5;
	return c;
}
/**
 * Multiplies two matrices. <code>b</code> matrix is multiplied with <code>a</code> matrix from right.
 * Dimensions of matrices are not important, except the width of <code>b</code> must be the same as height of <code>a</code> matrix.
 *
 * @return <code>double[][]</code> product of b*a
 * @param b the left <code>double[][]</code> matrix
 * @param a the right <code>double[][]</code> matrix
 */
public static double[][] multiply (double[][] b, double[][] a ) {
	return multiply(b,a,new double[b.length][a[0].length]);
}
/**
 * Multiplies two matrices. <code>b</code> matrix is multiplied with <code>a</code> matrix
 * from right. Dimensions of matrices are not important, except the width of
 * <code>b</code> must be the same as height of <code>a</code> matrix.
 *
 * @return <code>double[][]</code> product of c=b*a
 * @param b the left <code>double[][]</code> matrix
 * @param a the right <code>double[][]</code> matrix
 * @param c result <code>double[][]</code> matrix
 */
public static double[][] multiply (double[][] b, double[][] a, double[][] c) {
	int l= a.length;
	int i, j, k;
	int bl= b.length;
	int al= a[0].length;
	for (i=0; i<bl; i++)
		for (k=0; k<al; k++) {
			c[i][k]=0.0;
			for (j=0; j<l; j++)
				c[i][k]+= b[i][j]*a[j][k];
		}
	return c;
}
/**
 * Multiplies matrix and vector. <code>b</code> matrix is multiplied with <code>a</code> vector from right.
 * The width of <code>b</code> must be the same as length of <code>a</code> vector.
 * Returned vector has the same length as <code>b</code> matrix height.
 *
 * @return <code>double[]</code> vector product of b*a
 * @param a the right <code>double[]</code> vector
 * @param x an array of {@link double} objects
 */
public static double[] multiply(double[][] a, double[] x) { //, int m, int n) {
	if (a[0].length != x.length)
		throw new ArrayIndexOutOfBoundsException("Width of matrix a must be equal to length of vector x");
	double[] b= new double[a.length];
	for (int i=0; i<a.length; i++)
		for (int j=0; j<x.length; j++)
			b[i]+= a[i][j]*x[j];
	return b;
}
/**
 * Returns the hyperbolic sinus of <code>double</code> value.
 *
 * @param a <code>double</code> value
 * @return the hyperbolic sinus of argument
 */
public static double sinh (double a ) {
	return (Math.exp(a)- Math.exp(-a))/2.0;
}
/**
 * Returns the sqare of <code>double</code> value.
 *
 * @param a <code>double</code> value
 * @return the square of argument
 */
public static double sqr(double a) {
	return Math.pow(a,2.0);
}
/**
 * Returns transpnder matrix.
 *
 * @return <code>double[][]</code> transponded matrix
 * @param m <code>double[][]</code> argument matrix
 */
public static double[][] transpond(double[][] m) {
	double[][] c= new double[m[0].length][m.length];
	for (int i=0; i<m.length; i++)
		for (int j=0; j<m[0].length; j++)
			c[j][i]= m[i][j];
	return c;
}
}
